## 브라우저
### 브라우저 렌더링
1. **HTML 파싱** - 브라우저는 HTML 문서를 파싱합니다. 이 때 브라우저는 태그/속성/텍스트/script 등의 최소단위인 토큰으로 나눠서 읽어들이고 이후 부모-자식 요소에 따라 DOM 트리를 구성합니다.
2. **CSS/CSSOM 구성** - CSS의 선택자/속성/값 등의 최소단위인 토큰으로 나눠서 읽어들이고 이후 부모-자식 요소에 따라 CSSOM 트리를 구성합니다.
3. **브라우저는 DOM 트리와 CSSOM 트리를 결합하여 렌터트리를 구성하고**, 각 노드의 위치와 크기를 계산하여 **레이아웃**을 구성합니다. 이 때 브라우저는 부모-자식 요소에 따라 기존의 트리를 변경하기도 하고, z-index나 :active와 같은 CSS 요소에 따라 배치를 다르게하기도 합니다.
4. 브라우저는 마지막으로 윈도우에 **페인팅**을 하여 유저에게 컨텐츠를 보여주게 됩니다.

### 브라우저 저장소
참고문서1 : https://ko.javascript.info/cookie
참고문서2 : https://ko.javascript.info/localstorage

1. **쿠키** : 쿠키는 웹 서버에서 만들어져서 HTTP 응답헤더를 통해 클라이언트로 전달되며 브라우저는 쿠키저장소에 쿠키를 저장합니다. 서버통신이 이뤄질 때 브라우저에서 자동으로 요청 헤더에 포함하여 전달합니다. 이 쿠키는 클라이언트에서 변조가 가능하기 때문에 XSRF 공격에 취약합니다. HTTP 헤더에서 쿠키를 변조해서 서버에 인증요청을 보내고 보안이 필요한 유저의 기능을 조작할 수 있기 때문입니다.
2. **로컬스토리지** : 로컬스토리지는 브라우저를 닫아도 데이터가 유지되는 브라우저의 저장공간입니다. 주로 사용자가 직접 환경설정을 한 데이터를 저장하여 사용합니다. 로컬스토리지는 자동으로 데이터를 포함하여 서버로 전송하지 않기 때문에 HTTP 헤더에서 조작하기 어렵습니다. 그러나 자바스크립트 내에서는 조작이 가능하기 때문에 여전히 해커가 코드를 조작할 경우 탈취의 위험이 있습니다. 대표적인 Js 메서드로는 setItem과 getItem이 있습니다.
3. **세션스토리지** : 세션스토리지는 저장공간은 서버 컴퓨터에 위치하고, 브라우저의 탭이 열렸을 때만 유지되며, 브라우저에서는 세션에 접근하기 위한 id와 같은 식별자만을 보관합니다. 브라우저에서 세션 스토리지에 접근할 때 식별자(세션id)를 Header에 담아 서버에 요청을 보내면, 서버에서는 세션id를 검증한 뒤 저장소에 있는 데이터를 활용하여 응답을 보내주게 됩니다.

### 브라우저 주소창에 Google.com을 입력하면 일어나는 일
1. 브라우저의 주소창에 문자열이 입력되면 먼저 브라우저는 스킴(scheme : http or https)이 있는지 없는지 여부를 식별하여 검색엔진을 돌릴지, 서버에 요청을 보낼지 식별합니다.
2. 스킴이 식별되어 서버에 요청을 보내게 된다면, 먼저 캐싱된 DNS 기록을 탐색합니다.
3. 캐싱된 DNS 기록이 없을 경우 DNS 서버가 호스팅하고 있는 IP주소를 찾기 위해 DNS Query를 보내게 됩니다 이 때, 루트네임서버 -> 도메인 네임 서버 -> url 네임 서버로 리다이렉트를 반복하여 URL과 완전히 일치하는 IP 주소를 찾게 됩니다.
4. 이렇게 TCP 연결이 되면, 서버에 get 요청으로 html 문서를 요청합니다.
5. 웹 서버는 URI에 포함된 문자열을 변조하여 악성코드가 배포되지 않도록 특수문자열을 검증하고, 요청 처리 결과에 따라 상태코드와 함께 웹 페이지의 데이터를 클라이언트에 전달합니다.
6. 웹 페이지는 브라우저 렌더링 과정을 통해 컨텐츠를 유저에게 페인팅하여 보여줍니다.

### DNS에 대해 설명해주세요
1. DNS(Domain Name System)은 인터넷에서 도메인 이름을 IP 주소로 변환하는 시스템입니다.
2. DNS는 최상위 도메인, 세컨드 레벨 도메인, 서브 도메인 등 계층적으로 도메인 네임을 관리합니다.
3. 사용자가 도메인 이름을 입력하면, 브라우저는 DNS에게 해당 도메인 이름의 IP 주소를 요청하고, DNS는 도메인 이름을 IP 주소로 변환하여 응답합니다.
4. DNS는 전 세계에 분산된 DNS 서버들로 구성되어 있으며, 도메인 이름과 IP 주소의 매핑 정보를 가지고 있습니다.

### 브라우저 렌더링 최적화
- 혹시 실례가 되지 않는다면, 제가 최적화를 시도해본 경험이 없어서 정확한 성능을 말씀드리기가 어려울 것 같습니다. 다만, 최적화 개념을 신경쓰면서 적용했던 사례들을 중심으로 말씀드려도 괜찮으실까요?
- ok
브라우저 렌더링 최적화를 위해 시도해본 방법은 1가지가 있습니다.
react-query 라이브러리를 활용하여 캐싱된 데이터를 식별하고 반환하는 로직입니다.
제가 사용한 방법은 staletime을 30초로 설정하여 30초 이전에 동일한 요청이 들어갈 경우 캐싱된 데이터를 반환하는 로직을 구성했습니다.
이 외에도 webp 이미지 형식을 활용하여 미디어 파일을 최적화하는 방법이 있는 것으로 알고 있습니다.