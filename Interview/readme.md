# 📃 Overview
## 인성
1) [자기소개 부탁드립니다.](#자기소개)
2) [자신의 강점과 약점은 무엇인가요?](#)
3) [가장 최근에 해결한 기술적인 문제는 무엇이었나요? / 최근 기억에 남는 에러에 대해 소개해주세요](#기술이슈에러)
4) [프론트엔드 개발자를 선택한 이유](#프론트엔드-개발자를-선택한-이유)
5) [비전공자로서 개발자 직업을 선택한 이유](#개발자로-진로를-정한-이유)
6) [개발자로서 5년 후 / 10년 후의 목표](#개발자로서-5년-후의-목표)
7) 회사를 선택하는 기준이 있다면 무엇인지 알려달라
8) [인생에서 어려운 문제를 해결한 경험이 있다면 알려달라]()
9) 본래 전공을 선택한 이유는?
10) 시간이 2주정도 주어진다면 어떤 것을 더 공부할 예정인가 / frontend 역량 향상을 위해 어떤 것을 학습할 생각인가?
11) 회사 지원 동기가 어떻게 되시나요.
12) [요즘 공부중이시는 것에 대해 설명해주세요.](#최근-공부하고-있는-것)
13) [새로운 기술을 습득하기 위해 어떠한 방식으로 연구하시나요?](#새로운-기술을-학습하기-위한-방법)
14) [협업을 하면서 갈등이 생겼던 경험이 있으신가요?](#협업에서-갈등이-생겼던-경험)
15) 본인이 자주 사용하는 웹 어플리케이션이 있다면 어떤게 있는지 설명해주세요. 그리고 왜 그 어플리케이션을 사용하시나요?
16) [본인이 사용하면서 결국 사용하지 않게 된 웹 어플리케이션 있다면 어떤게 있는지 설명해주세요. 그리고 왜 그 어플리케이션을 사용하시지 않게 되셨나요?](#사용하지-않게-된-어플리케이션)
17) 만나고 싶지 않은 사수

## 브라우저
1) [브라우저 렌더링 과정에 대해서 설명해보세요.](./Browser/readme.md/#브라우저-렌더링)
2) [브라우저 저장소에 대해 아는대로 설명해주세요](./Browser/readme.md/#브라우저-저장소)
3) [브라우저 주소창에 google을 입력하면 발생하는 일을 설명해주세요.](./Browser/readme.md/#브라우저-주소창에-googlecom을-입력하면-일어나는-일)
4) [DNS에 대해 설명해주세요.](./Browser/readme.md/#dns에-대해-설명해주세요)
5) [페이지 로드 시간을 줄이는 방법들에 대해서 설명해주세요.](./Browser/readme.md/#브라우저-렌더링-최적화)

## HTML&CSS
1) [CSS Postion에 대해 설명해보세요. => relative / fix / absolute](#css-postion에-대해-설명해보세요--relative--fix--absolute)
2) [Flex와 Grid의 차이점에 대해서 설명해보세요.](#flex와-grid의-차이)
3) [반응형 웹의 구현](#반응형-웹)
4) form 요소의 동작방식 + react-form 사용경험에 대해 설명해주세요
5) CSS 박스모델 margin/padding이 차지하는 크기는 어떻게 되나요?
6) HTML에서의 attributes와 properties의 차이점을 설명해주세요.
7) [Sementic Markup에 대해 설명해주세요.](#시맨틱-마크업)
8) SASS, SCSS를 사용해보신 경험이 있다면 설명해주세요.

## JS
1) [호이스팅](#호이스팅)
2) [스코프와 클로저란 무엇인가요?](#스코프와-클로저)
3) [콜백함수와 콜백지옥을 해결하는 방법](#콜백지옥)
4) [async/await에 대해 설명해보세요.](#asyncawait)
5) ["==" 와 "==="의 차이는 무엇인가요?]()
6) 이벤트루프 & 비동기
7) 싱글스레드와 멀티스레드
8) constructor & class & instance
9) ES5와 ES6의 차이
10) require와 import의 차이
11) 화살표 함수를 사용하는 이유
12)
13) map과 foreach의 차이에 대해 설명
14) 이벤트 버블링과 이벤트 캡쳐에 대해 설명해주세요
15) 이벤트 위임 패턴에 대해 설명해주세요
16) DOM에 대해 설명해주세요.
17) Promise에 대해 설명해주세요
18) 얕은 복사와 깊은 복사의 차이를 설명해주세요
19) 프로토타입과 this

## TS
1) 타입스크립트 사용 경험
2) 타입스크립트의 장단점
3) 타입스크립트에서의 배열작동 원리
4) any타입과 unknown 타입을 비교해서 설명해주세요
5) 유니온 타입은 언제 사용하나요?
6) 타입스크립트에서는 어떻게 객체를 생성하게 되나요?

## Next.js
1) 사용경험
2) SSR / CSR / CSG 방식의 차이

## React 라이브러리
1) 어떤 프레임워크를 사용하여 개발했나요? 왜 그 프레임워크를 선택했나요?
2) 클래스형 컴포넌트와 함수형 컴포넌트의 차이는 무엇일까요?
3) useMemo/useCallback vs useState/useEffect
4) Virtual DOM에 대해 설명해주세요.
5) 클래스형 컴포넌트와 함수형 컴포넌트의 차이를 설명해주세요.
6) React의 장점과 단점을 설명해주세요.
7) JSX에 대해 설명해주세요.
8) 브라우저는 JSX 파일을 읽을 수 있나요?
9) 재조정(Reconciliation) 개념에 대해서 설명해주세요.
10) state와 props의 차이를 설명해주세요.
11) 자식 컴포넌트에서 props를 변경할 수 있나요?
12) React Hooks에 대해 설명해주세요.
13) React Lifecycle에 대해 설명해주세요.
14) useEffect와 useLayoutEffect의 차이 대해 설명해주세요.
15) state를 직접변경하지 않고 setState를 사용하는 이유를 설명해주세요.
16) React rendering 성능을 향상시키기 위한 방법들을 설명해주세요.
17) Props drilling의 개념과 Props drilling을 피하는 방법에 대해 설명해주세요.
18) 전역 상태 관리 방법에 대해 설명해주세요.

## 통신
1) RESTful API에 대해 설명해주세요.
2) 그렇다면 HTTP 메소드에 대한 설명도 해주실 수 있나요?
3) HTTP와 HTTPS의 차이
4) CORS에러를 해결하는 방법

## 보안
1) CSRF나 XSS 공격을 막는 방법은?

## 프로젝트
1) 프로젝트에서 어떤 것을 담당하셨나요?
2) [팀원들간의 갈등은 어떻게 해결하셨나요?](#협업에서-갈등이-생겼던-경험)
3) [백엔드와 소통은 어떻게 진행하셨나요?](#)
4) 프로젝트 안에서 자신의 의견이 관철되었던 경험을 이야기해주세요.
5) 프로젝트의 아키텍쳐에 대해 설명해주세요
6) 전역상태관리 라이브러리로 Redux나 RTK를 사용하시지 않고, Recoil를 사용하신 이유는 무엇인가요? 실제로 구현 단계에서 스스로 코드를 작성하셨나요?
7) 프로젝트에서 CloudFront를 사용하신 이유에 대해 설명해주세요.

## 자료구조
1) 해시와 리스트을 활용한 구현

## 테스팅
1) 테스팅을 해보신 경험이 있나요? 있다면 어떤 계기로 테스팅을 도입하시게 되었나요?
2) TDD란 무엇인가요?
3) 유닛테스트와 통합테스트
4) Jest의 선언 & describe & it

## 배포
1) 웹 서비스 배포 시스템 구축 경험이 있으신가요?
2) 정적 사이트 vs 동적 사이트
3) 무중단 배포에 대해 알고 계신가요?
4) CI/CD에 대해 설명해 주세요.

## 소프트웨어 아키텍쳐
1) MVVM패턴과 Flux패턴의 차이점에 대해서 설명해보세요.

## CS
1) iterable / iterator
2) generator
3) 프로세스와 스레드의 차이
4) 객체지향 프로그래밍에 대해 설명
5) 객체 지향 프로그래밍에 대해 설명해주세요.
6) 멀티 프로세스와 멀티 스레드의 차이에 대해 설명해주세요.
7) List, Map, Set의 차이점을 설명해주세요.
8) 라이브러리와 프레임워크의 차이점을 설명해주세요.

## 리팩토링
1) 짧지 않은 시간동안 리팩토링을 하면서 어떤 것을 학습하셨나요?
2) 리팩토링을 하면서 가장 신경썼던 부분은 무엇인가요?
3) Vite와 Vitest를 사용하신 이유에 대해 설명해주세요
4) React-query를 도입하시면서 얻으신 이점에 대해 설명해주세요

## git 협업
1) git을 활용해서 협업을 진행해본 경험에 대해 설명해주세요

## 네트워크
1) TCP/IP 4계층에 대해 아는대로 설명해보세요.

## Chat GPT
1) Chat GPT를 사용해보신 경험이 있는가요? 있다면 어떤 경우에 주로 사용하셨나요?

# 🙋 나만의 답안

## 인성
### 자기소개
안녕하세요. 슬링 프론트엔드 직무에 지원한 강하성이라고 합니다. 저는 안정적이고 직관적인 웹 서비스를 개발하고자 프론트엔드 직무에 지원했습니다. 안정적인 웹 서비스를 제공하기 위해서는 개발 단계에서 자료구조를 활용한 메서드들에 대한 다양한 유닛테스트가 필요하다고 생각되었습니다. 부트캠프 수료 이후 프로젝트를 리팩토링 하는 과정에서 Vitest 라이브러리를 활용하여 바이너리 형식으로 서버에 저장된 데이터가 넘버 타입으로 구성된 리스트로 넘어올 때 특정 문자열 형식으로 잘 출력되는지 테스트하는 코드를 2가지 경우의 수로 쪼개어 총 4가지의 경우를 테스트하는 코드를 작성했습니다. 또한 보안을 강화하고자 서버에 보내는 쿼리를 Base64 형식으로 인코딩하는 과정에서도 boolean, 문자열, 숫자열의 조합 형식도 테스트코드를 활용하여 테스팅했습니다. 그리고 리팩토링 과정에서 직관적인 경험을 강화하기 위해 총 10개 페이지에서 유저와 상호작용이 이뤄지는 요소마다 CSS 요소를 추가하여 유저가 원하는 동작에 대한 집중도를 높혔습니다.

### 강점과 약점
스스로 저의 강점은 일에 열정적이고 긍정적인 마음으로 임하는 것이라 생각합니다. 이와 관련하여 부트캠프에서 있었던 경험을 짧게 공유드려도 괜찮으실까요?
- (if,Ok not "약점까지 다 이야기하고..")
저는 대학을 졸업한 직후에 부트캠프에 들어와 처음 코드를 접했습니다. 이로 인해 5개월간 열심히 노력했음에도 Restful API에서 전달되는 JSON 데이터와 Form-data도 구분하지 못했고 타입스크립트도 알지 못한 채 프로젝트에 진입했습니다. 하지만 누구에게나 처음은 있고, 이 문법들이 모두 제가 배운 자바스크립트와 AJAX의 문제를 개선한 방법들이라면 분명 전혀 다른 개념이 아닌 오히려 더 효율적이고 편리한 기능들이라 생각하며 프로젝트 중에 구현과 학습을 병행했습니다. 이러한 열정과 마인드를 바탕으로 프로젝트를 기한 내에 끝낼 수 있었습니다.

스스로 저의 단점은 기술적인 용어와 개념에 대한 이해의 부족이라 생각합니다. 동일하게 경험으로 말씀드려도 괜찮으실까요? (Ok) 저는 백엔드 동료분들께서 말씀하시는 컨트롤러, 데이터 타입 등에 대한 이해가 부족했습니다. 하지만 결국 프로젝트에서 백엔드와 프론트엔드가 각각 독립된 배포환경을 먼저 구성했고, API 명세서를 통해 명확한 소통이 가능하다면 적극적인 테이블과 필드의 추가를 요청드리고, 모르는 개념은 멘토님께 적극적으로 문의드리며 부족한 부분을 보충했습니다. 회사에 입사해서도 동일하게 저는 부족한 부분과 필요한 부분에 대해 어필하고 문의드리면서 성장해 나갈 것입니다.

### 기술이슈&에러
가장 최근에 접한 기술 이슈는 스터디 정보를 업데이트하는 컴포넌트를 설계했을 때 발생한 이슈입니다.

기존에 해당 컴포넌트는 useEffect Hook을 활용하여 기존의 스터디 정보를 호출하고, 이 정보를 then 메서드를 활용하여 콜백함수의 파라미터로 전달한 뒤 상태변경함수에 할당하여 초기 상태를 설정했습니다.

이렇게 호출할 경우 발생하는 문제는 상태변경함수에 제대로 할당이 되지 않았거나, 타입이 맞지 않아 useEffect 함수 내부에서 제대로 처리되지 않아도 다음 코드줄이 실행되어 막상 유저가 보는 윈도우에서는 초기값이 할당되지 않았지만 업데이트 기능은 정상적으로 작동하는 이슈가 있었습니다.

이 외에도 필요한 모든 상태를 각각의 useState로 두어 가독성을 해치고, 상태변경 과정을 추론하기 어렵다는 문제가 있었습니다.

이를 개선하고자
첫번째로는 async-await 구문을 활용하여 useEffect 내부의 처리가 끝날때까지 다음 스크립트에 대한 인터프리팅을 멈출 수 있도록 설정했습니다.
두번째로는 서버에서 불러온 데이터를 하나의 상태에 객체로 담아 구조분배할당을 활용하여 관리할 수 있도록 수정했습니다.

이렇게 개선함으로서 상태변경험수의 호출에서 발생하는 연산의 오버헤드를 방지했으며 가독성을 높이고 서버 통신 상에서 발생할 수 있는 이슈를 잡을 수 있었습니다.

### 프론트엔드 개발자를 선택한 이유
프론트엔드 개발자를 선택한 이유는 브라우저 바깥에서 밖에 할 수 없는 기능을 브라우저 내부의 윈도우에서 조작할 수 있도록 개발한다는 매력 때문이었습니다. 실례로 저는 구글독스나 한컴독스를 접하기 전까지는 모든 문서작업을 한컴오피스, MS OFFICE로 진행했습니다. 하지만 웹에서 제공하는 도큐먼트 서비스를 접하고 나서는 PPT는 미리캔버스나 캔바, 문서는 구글독스, 소통은 구글미트나 웹용 디스코드로 전부 전환했습니다. 이 모든 것이 웹 도큐먼트을 넘어선 웹 애플리케이션으로 안정적으로 동작했기 때문에 가능한 것이고, 이는 선배 프론트엔드 개발자들께서 개발하신 결과물이기에 저 또한 그러한 결과물을 만들어내고 싶어서 프론트엔드를 지망했습니다.

### 개발자로 진로를 정한 이유
개발자로 진로를 정한 이유는 협업과 문제해결과정을 통해 무언가를 구현한다는 점 때문이었습니다.
협업과 문제해결과정은 제 스스로의 한계에 갇혀있지 않고 끊임없이 성장할 수 있는 원동력이며, 그 결과물이 사용자에게 잊지 못할 경험으로 제공된다면 유저의 삶의 한 부분에 기여할 수 있다는 점이 큰 매력으로 다가왔습니다.

### 개발자로서 5년 후의 목표
저는 향후에 소방수가 되는 것이 최종 목표입니다. 소방수라는 단어의 의미를 알게 된 계기는 멘토님과의 멘토링 시간을 통해서입니다. 그 때, 여러 훌륭한 개발자분들께서 계시지만 상대적으로 보이지 않는 자리에서 서비스를 위해 개발상의 이슈를 총체적으로 다루고 어떤 문제든 해결하시는 선배님들께서 계시다는 말씀을 들었습니다.
이 모습은 팀원과의 협업 상에서 발생하는 문제들을 팀 멤버쉽을 갖고 하나의 결과물을 위해 적극적으로 협업하여 해결하는 모습으로 다가왔습니다. 물론 프론트엔드에서 새로운 패러다임을 찾는 개발자도 매력적이지만, 현 시점의 저에게는 서비스에 필요한 기능을 총괄적으로 바라보고, 오류를 빠르게 파악해서 유저에게 필요한 기능을 안정적으로 제공하는게 더 매력적으로 다가왔습니다.

### 새로운 기술을 학습하기 위한 방법
저는 새로운 기술을 습득하기 전에 해당 기술이 어느 레이어에 위치한지 파악하고자 노력합니다.
일례로, typescript나 서드파티 라이브러리는 공식문서의 quick start를 읽고 직접 적용해보고, github에서 best practice를 탐색해보면서 학습하면 필요한 부분을 상대적으로 빨리 적용할 수 있는 학습 분야라고 생각합니다.
반대로 Next.js나 Testing-Library는 기존에 제가 접하지 못한 SSR이라는 렌더링 방식을 다루든지, 테스팅 트로피 혹은 피라미드에 따른 유닛/통합 테스트의 흐름에 적용해야 하기 때문에 공식문서만 보고 필요한 부분을 바로 잡아내기가 쉽지 않았습니다. 이러한 개념들은 짧고 직관적인 강의를 통해 간단한 결과물을 만들면서 Overview를 한 뒤 실제 프로젝트에 적용해보면서 학습을 하고 있습니다.

### 사용하지 않게 된 어플리케이션
Notion을 대표적인 예로 들 수 있을 것 같습니다. Notion은 데이터베이스나 카드, 코드블럭, 그룹페이지 등의 강력한 기능을 제공하고 있고 실시간 타이핑을 활용한 의사소통이 가능하기 때문에 효율적인 웹 어플리케이션이라고 생각합니다. 하지만 화면 렌더링이 많이 느리고, 참여자가 많을수록 부하가 가중되며, 브라우저 메모리 공간을 많이 차지하는지 웹 동작속도 자체가 느려짐을 경험했습니다.
대부분의 커뮤니케이션은 구조화된 데이터 양식보다는 단순한 채팅과 이를 정리하는 도큐먼트로 해결이 가능하기 때문에 현재는 노션을 사용하지 않게 되었습니다. 만약 다시 데이터베이스와 일정관리 기능처럼 복잡한 로직을 한눈에 정리할 웹 어플리케이션을 사용한다면 slack이나 다른 협업 어플리케이션을 찾아보고 고민하겠습니다.

### 최근 공부하고 있는 것
현재 리팩토링이 어느정도 마무리 된 후 성능 최적화와 컴포넌트 렌더링을 통한 통합 테스트를 학습하고 있습니다.
이후에는 인프런에서 차크라 UI, Firebase, Next.js를 활용한 5시간짜리 강의를 끊어놓고 해당 강의를 통해 최근 프론트엔드 트렌드에 맞는 기술을 학습하려고 준비중에 있습니다.

하지만 주요 트렌드를 학습하기 이전에 현재 제가 설계한 리팩토링 프로젝트의 성능 개선의 수치화와 통합 테스트를 통한 안정성 확보가 좀 더 우선적이라 생각하여 그 부분을 중점에 두고 학습하고 있습니다.

### 인생에서 어려운 문제를 해결한 경험
(?)대학교 12인 팀프로젝트 과제
- 수업의 주제는 종교철학 -> 교수님께서

### 협업에서 갈등이 생겼던 경험
혹시, 괜찮으시다면 팀 프로젝트내에서 일어난 감정적인 갈등이 아닌 기획단계과 진행과정에 있었던 의사소통간의 갈등으로 소개드려도 괜찮으실까요?
- ok
기획 단계에서 큰 틀의 아이디어는 정해졌지만, 최소사양을 어느정도로 둘 것인가와 중간점검에서 프론트엔드 부분이 전부 구현이 되지 않았던 상황에서 의견 충돌이 있었습니다.
당시 팀프로젝트에 익숙치 않았던 상황이어서 저희가 어느정도까지 구현할 수 있는지, 그리고 프로젝트를 통해서 어떤 결과물을 각자 가져갈 것인지에 대해 조율하기 어려운 상태에서 기인한 문제였습니다.

저는 이를 github의 discussion과 지속적인 상황공유, 중간 결과물을 계속해서 리포트하고 피드백을 받는 것으로 개선했습니다. 이에 적응하는데 다소간의 시간이 필요했으나, 이를 통해 백엔드에서 필드값만 추가해주면 쉽게 해결될 문제들을 빠르게 개선할 수 있었고, 반드시 알아야 하는데 잘 몰랐던 개념들을 인지하고 즉각적으로 학습하여 개선할 수 있었습니다.

## HTML&CSS
### CSS Postion에 대해 설명해보세요. => relative / fix / absolute
저는 CSS Position을 다룰 때 해당 요소가 어느 요소를 참조하고 있는지를 가장 많이 고려하고 있습니다.
**relative**의 경우 부모요소와 해당 요소가 갖고 있는 margin 값에 따라 요소가 배치됩니다.
**absolute**의 경우는 조상요소의 postion을 참조하여 요소가 배치됩니다. 저는 프로젝트 내부에서 absolute를 자주 활용할만한 사례가 없었지만, 만약 사용하게 된다면 아주 복잡한 레이아웃에서 부모요소와 관계없이 그보다 상위 요소에 유저의 집중이 머무르는 요소를 구현할 때 absolute를 사용할 것 같습니다.
**fix**는 뷰포트를 참조하여 요소의 위치를 정하게 됩니다.

### Flex와 Grid의 차이
flex는 주로 행과 열 중 하나에 집중해서 다루고 있습니다. 반면에 grid는 행과 열을 동시에 다루고 있습니다.
이러한 특징으로 인해 Flex는 콘텐츠의 변경사항에 따라 유연하게 배치가 가능하며, 향후 추가적인 유지보수에도 유리한 측면이 있습니다. 반면에 grid는 복잡한 애플리케이션의 전반적인 틀을 제어하는데 유리합니다.

### 반응형 웹
반응형 웹은 웹 어플리케이션을 데스크탑이 아닌 다양한 디바이스에서 크기를 조절하며 동작할 수 있도록 조절하는 웹을 말합니다. 이를 구현할 수 있는 기술로는 미디어 쿼리가 있습니다. 미디어쿼리는 미디어 유형을 일정한 변수에 저장하고, window. 객체에서 식별하여 다양한 스타일이 가능하도록 합니다.

### 시맨틱 마크업
시멘틱 마크업은 HTML의 시맨틱 태그를 활용하여 의미론적 HTML 구성을 만드는 것을 의미합니다.
h1태그나 article 태그가 이에 해당하며, 해당 태그들은 모두 div 태그와 같이 블록요소들이지만 제목/일반 본문이라는 의미를 내포하고 있는 요소들입니다.
시맨틱 마크업을 사용할 경우, 검색엔진 최적화와 웹 접근성 향상에 유리합니다.
검색엔진은 메타태그와 마크업 태그를 통해 해당 웹의 정보를 구조화하여 사용자에게 노출하고, 브라우저는 접근성이 상대적으로 떨어지는 사용자에게 의미론적 태그를 활용하여 감각적 자료를 제공하기 때문입니다.

## JS
### 호이스팅
호이스팅이란 자바스크립트가 코드를 읽어들일 때 변수와 함수선언을 스코프의 상단으로 끌어올리는 현상을 말합니다.
이 때, 스코프 상단으로 끌어올려진 **변수와 함수, 원시데이터가 할당된 객체는 자바스크립트의 메모리 힙에 저장**되며, **힙에 저장되지 않은 상태에서 변수나 함수를 실행하는 컨텍스트가 생성되면 자바스크립트는 reference error**를 리턴합니다. 이렇게 메모리 힙에 담겨있는 **데이터를 실행시킬 때 call stack으로 Push**되며, 실행이 완료될 경우 call stack에서 제거되게 됩니다.

### 스코프와 클로저
스코프는 변수나 함수의 접근 범위를 의미합니다.
스코프에 종류에는 전역 스코프와 지역스코프가 있습니다.
=> 여러 함수가 중첩된 경우 : 스코프 체인 => 함수는 상위 스코프를 참조한다
=> 변수의 생명주기는 함수의 생명주기를 따른다
=> 함수 외부에서 함수가 호출될 때 함수 내부에 있는 변수에 접근가능한 형식을 렉시컬 스코프라 말한다.

클로저는 내부 함수가 외부 함수 변수에 접근할 수 있는 환경을 의미합니다. 모든 함수는 호출된 시점에서 가장 가까이 있는 스코프를 참조합니다. 따라서 외부함수의 실행이 끝나서 변수의 생명주기가 끝났음에도 외부함수를 호출함으로서 생명주기가 끝난 변수에 접근할 수 있는 환경이 만들어지는 것을 클로저라고 합니다.

### 콜백지옥
콜백함수는 다른 함수의 인자로 전달되어 특정 함수의 작업이 완료되었을 때 호출되는 함수를 말합니다. 어플리케이션이 고도화됨에 따라 다양한 함수들이 중첩하여 특정한 조건을 형성하게 되었는데, 이 때 과도하게 중첩된 함수의 형태를 콜백지옥이라 부릅니다.
2015년에 출시된 JS 2015에서는 Promise 객체를 활용하여 대기/이행/거부 상태를 리턴함으로 함수의 동작순서와 상태를 정의할 수 있도록 했습니다.
또한 ES8에서는 async/await 함수를 도입하여 비동기적으로 동작하는 Promise 객체를 동기적으로 제어할 수 있도록 메서드를 제공했습니다.

### async/await
